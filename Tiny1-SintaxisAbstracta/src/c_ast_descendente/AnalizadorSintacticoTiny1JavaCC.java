/* Generated By:JavaCC: Do not edit this line. AnalizadorSintacticoTiny1JavaCC.java */
package c_ast_descendente;
import asint.Tiny1Asint.*;
import semops.SemOps;
public class AnalizadorSintacticoTiny1JavaCC implements AnalizadorSintacticoTiny1JavaCCConstants {
        private SemOps sem = new SemOps();

  final public Prog Sp() throws ParseException {
                                           Prog prog;
    prog = S();
    jj_consume_token(0);
                                                                          {if (true) return prog;}
    throw new Error("Missing return statement in function");
  }

  final public Prog S() throws ParseException {
                                           LDecs decs; LInsts linsts;
    decs = Decs();
    linsts = LInsts();
                                                                                                         {if (true) return sem.prog(decs,linsts);}
    throw new Error("Missing return statement in function");
  }

  final public LDecs Decs() throws ParseException {
                                   LDecs decs;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Var:
    case Type:
    case Proc:
      decs = LDecs();
      jj_consume_token(42);
                                                                      {if (true) return decs;}
      break;
    default:
      jj_la1[0] = jj_gen;

                                                                                         {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LDecs LDecs() throws ParseException {
                                   LDecs ldecs; Dec dec;
    dec = Dec();
    ldecs = RLDecs(sem.decs_una(dec));
                                                                                                         {if (true) return ldecs;}
    throw new Error("Missing return statement in function");
  }

  final public LDecs RLDecs(LDecs ldecsh) throws ParseException {
                                                   LDecs ldecs; Dec dec;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      dec = Dec();
      ldecs = RLDecs(sem.decs_muchas(ldecsh,dec));
                                                                                                                                     {if (true) return ldecs;}
      break;
    default:
      jj_la1[1] = jj_gen;

                                                                                                                                                          {if (true) return ldecsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Dec Dec() throws ParseException {
                                           Tipo tipo; Token id; Paramsf paramsf; Bloque bloque;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Var:
      jj_consume_token(Var);
      tipo = Tipo();
      id = jj_consume_token(Id);
                                                                                                                                {if (true) return sem.dec_var(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case Type:
      jj_consume_token(Type);
      tipo = Tipo();
      id = jj_consume_token(Id);
                                                                                                                                                                                                    {if (true) return sem.dec_type(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case Proc:
      jj_consume_token(Proc);
      id = jj_consume_token(Id);
      jj_consume_token(44);
      paramsf = ParamsF();
      jj_consume_token(45);
      bloque = Bloque();
                                                                                                                                                                                                                                     {if (true) return sem.dec_proc(sem.str(id.image,id.beginLine,id.beginColumn),paramsf,bloque);}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Paramsf ParamsF() throws ParseException {
                                           Lparamsf lparamsf;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TipoInt:
    case TipoReal:
    case TipoBool:
    case TipoString:
    case Record:
    case Array:
    case Pointer:
    case Id:
      lparamsf = LParamsF();
                                                                                       {if (true) return sem.paramsf_no_vacio(lparamsf);}
      break;
    default:
      jj_la1[3] = jj_gen;

                                                                                                                                     {if (true) return sem.paramsf_vacio();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Lparamsf LParamsF() throws ParseException {
                                           Paramf paramf; Lparamsf lparamsf;
    paramf = ParamF();
    lparamsf = RLParamsF(sem.lparamsf_uno(paramf));
                                                                                                                                             {if (true) return lparamsf;}
    throw new Error("Missing return statement in function");
  }

  final public Lparamsf RLParamsF(Lparamsf lparamsfh) throws ParseException {
                                                   Lparamsf lparamsf; Paramf paramf;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      paramf = ParamF();
      lparamsf = RLParamsF(sem.lparamsf_muchos(lparamsfh,paramf));
                                                                                                                                                                           {if (true) return lparamsf;}
      break;
    default:
      jj_la1[4] = jj_gen;

                                                                                                                                                                                                   {if (true) return lparamsfh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Paramf ParamF() throws ParseException {
                                   Tipo tipo; Paramf paramf;
    tipo = Tipo();
    paramf = RParamF(tipo);
                                                                                                     {if (true) return paramf;}
    throw new Error("Missing return statement in function");
  }

  final public Paramf RParamF(Tipo tipo) throws ParseException {
                                                   Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 47:
      jj_consume_token(47);
      id = jj_consume_token(Id);
                                                                            {if (true) return sem.paramf_referencia(tipo, sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case Id:
      id = jj_consume_token(Id);
                                                                                                                         {if (true) return sem.paramf_valor(tipo,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    default:
      jj_la1[5] = jj_gen;

                                                                                                                    {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Tipo Tipo() throws ParseException {
                                           Token id; Tipo tipo; LTipos ltipos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TipoInt:
      jj_consume_token(TipoInt);
                                                                                            {if (true) return sem.tipo_int();}
      break;
    case TipoReal:
      jj_consume_token(TipoReal);
                                                                                                                                 {if (true) return sem.tipo_real();}
      break;
    case TipoBool:
      jj_consume_token(TipoBool);
                                                                                                                                                    {if (true) return sem.tipo_bool();}
      break;
    case TipoString:
      jj_consume_token(TipoString);
                                                                                                                                                                                            {if (true) return sem.tipo_string();}
      break;
    case Id:
      id = jj_consume_token(Id);
                                                                                                                                                 {if (true) return sem.tipo_ref(sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case Array:
      jj_consume_token(Array);
      jj_consume_token(48);
      id = jj_consume_token(Entero);
      jj_consume_token(49);
      jj_consume_token(Of);
      tipo = Tipo();
                                                                                                                                                                                      {if (true) return sem.tipo_array(sem.str(id.image,id.beginLine,id.beginColumn),tipo);}
      break;
    case Record:
      jj_consume_token(Record);
      jj_consume_token(50);
      ltipos = LTipos();
      jj_consume_token(51);
                                                                                                                                                                          {if (true) return sem.tipo_record(ltipos);}
      break;
    case Pointer:
      jj_consume_token(Pointer);
      tipo = Tipo();
                                                                                                                                                               {if (true) return sem.tipo_pointer(tipo);}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public LTipos LTipos() throws ParseException {
                                   LTipos ltipos; Tipo tipo;Token id;
    tipo = Tipo();
    id = jj_consume_token(Id);
    ltipos = RLTipos(sem.tipos_uno(tipo,sem.str(id.image,id.beginLine,id.beginColumn)));
                                                                                                                                                                                 {if (true) return ltipos;}
    throw new Error("Missing return statement in function");
  }

  final public LTipos RLTipos(LTipos ltiposh) throws ParseException {
                                                   LTipos ltipos; Tipo tipo;Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      tipo = Tipo();
      id = jj_consume_token(Id);
      ltipos = RLTipos(sem.tipos_muchos(ltiposh,tipo,sem.str(id.image,id.beginLine,id.beginColumn)));
                                                                                                                                                                                                       {if (true) return ltipos;}
      break;
    default:
      jj_la1[7] = jj_gen;

                                                                                    {if (true) return ltiposh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public LInsts LInsts() throws ParseException {
                                   Inst inst; LInsts linsts;
    inst = Inst();
    linsts = RLInsts(sem.insts_una(inst));
                                                                                                                {if (true) return linsts;}
    throw new Error("Missing return statement in function");
  }

  final public LInsts RLInsts(LInsts linstsh) throws ParseException {
                                                   Inst inst; LInsts linsts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      inst = Inst();
      linsts = RLInsts(sem.insts_muchas(linstsh,inst));
                                                                                                                                               {if (true) return linsts;}
      break;
    default:
      jj_la1[8] = jj_gen;

                                                                                                                                                                    {if (true) return linstsh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst Inst() throws ParseException {
                                           Exp exp0; Exp exp1; Insts insts; Bloque bloque; Paramsr paramsr; Token id; Inst inst;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Not:
    case True:
    case False:
    case Null:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
    case 54:
    case 57:
      exp0 = E0();
      jj_consume_token(52);
      exp1 = E0();
                                                                                                                                                  {if (true) return sem.inst_asig(exp0,exp1);}
      break;
    case If:
      jj_consume_token(If);
      exp0 = E0();
      jj_consume_token(Then);
      insts = Insts();
      inst = RInst(exp0,insts);
                                                                                                                                                                                    {if (true) return inst;}
      break;
    case While:
      jj_consume_token(While);
      exp0 = E0();
      jj_consume_token(Do);
      insts = Insts();
      jj_consume_token(Endwhile);
                                                                                                                                                                         {if (true) return sem.inst_while(exp0,insts);}
      break;
    case Read:
      jj_consume_token(Read);
      exp0 = E0();
                                                                                                                                          {if (true) return sem.inst_read(exp0);}
      break;
    case Write:
      jj_consume_token(Write);
      exp0 = E0();
                                                                                                                                                                                           {if (true) return sem.inst_write(exp0);}
      break;
    case Nl:
      jj_consume_token(Nl);
                                                                                                                              {if (true) return sem.inst_nl();}
      break;
    case New:
      jj_consume_token(New);
      exp0 = E0();
                                                                                                                                                                       {if (true) return sem.inst_new(exp0);}
      break;
    case Delete:
      jj_consume_token(Delete);
      exp0 = E0();
                                                                                                                                            {if (true) return sem.inst_delete(exp0);}
      break;
    case Call:
      jj_consume_token(Call);
      id = jj_consume_token(Id);
      jj_consume_token(44);
      paramsr = ParamsR();
      jj_consume_token(45);
                                                                                                                                                                  {if (true) return sem.inst_call(sem.str(id.image,id.beginLine,id.beginColumn),paramsr);}
      break;
    case 50:
      bloque = Bloque();
                                                                                                                                         {if (true) return sem.inst_bloque(bloque);}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Inst RInst(Exp exp, Insts insts) throws ParseException {
                                                           Insts insts1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Endif:
      jj_consume_token(Endif);
                                                                                    {if (true) return sem.inst_if(exp,insts);}
      break;
    case Else:
      jj_consume_token(Else);
      insts1 = Insts();
      jj_consume_token(Endif);
                                                                                                                                                    {if (true) return sem.inst_if_else(exp,insts,insts1);}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Paramsr ParamsR() throws ParseException {
                                           Lparamsr lparamsr;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Not:
    case True:
    case False:
    case Null:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
    case 54:
    case 57:
      lparamsr = LParamsR();
                                                                                     {if (true) return sem.paramsr_no_vacio(lparamsr);}
      break;
    default:
      jj_la1[11] = jj_gen;

                                                                                                                                  {if (true) return sem.paramsr_vacio();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Lparamsr LParamsR() throws ParseException {
                                           Exp exp; Lparamsr lparamsr;
    exp = E0();
    lparamsr = RParamsR(sem.lparamsr_uno(exp));
                                                                                                                            {if (true) return lparamsr;}
    throw new Error("Missing return statement in function");
  }

  final public Lparamsr RParamsR(Lparamsr lparamsrh) throws ParseException {
                                                           Exp exp; Lparamsr lparamsr;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 46:
      jj_consume_token(46);
      exp = E0();
      lparamsr = RParamsR(sem.lparamsr_muchos(lparamsrh,exp));
                                                                                                                                                             {if (true) return lparamsr;}
      break;
    default:
      jj_la1[12] = jj_gen;

                                                                                                                                                                                    {if (true) return lparamsrh;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Insts Insts() throws ParseException {
                                   LInsts linsts;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Not:
    case True:
    case False:
    case Null:
    case If:
    case While:
    case Call:
    case New:
    case Delete:
    case Read:
    case Write:
    case Nl:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
    case 50:
    case 54:
    case 57:
      linsts = LInsts();
                                                                       {if (true) return sem.insts_no_vacia(linsts);}
      break;
    default:
      jj_la1[13] = jj_gen;

                                                                                                                 {if (true) return sem.insts_vacia();}
    }
    throw new Error("Missing return statement in function");
  }

  final public Bloque Bloque() throws ParseException {
                                   Bloque bloque;
    jj_consume_token(50);
    bloque = RBloque();
                                                                          {if (true) return bloque;}
    throw new Error("Missing return statement in function");
  }

  final public Bloque RBloque() throws ParseException {
                                           Prog prog;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Not:
    case True:
    case False:
    case Var:
    case Type:
    case Proc:
    case Null:
    case If:
    case While:
    case Call:
    case New:
    case Delete:
    case Read:
    case Write:
    case Nl:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
    case 50:
    case 54:
    case 57:
      prog = S();
      jj_consume_token(51);
                                                                      {if (true) return sem.bloque_no_vacio(prog);}
      break;
    case 51:

                                                                                                              {if (true) return sem.bloque_vacio();}
      jj_consume_token(51);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E0() throws ParseException {
                                           Exp exp; Exp exp0;
    exp0 = E1();
    exp = RE0(exp0);
                                                                                         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE0(Exp exph) throws ParseException {
                                                   Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 53:
      jj_consume_token(53);
      exp = E0();
                                                                            {if (true) return sem.exp("+",exph, exp);}
      break;
    case 54:
      jj_consume_token(54);
      exp = E0();
                                                                                                                           {if (true) return sem.exp("-",exph,exp);}
      break;
    default:
      jj_la1[15] = jj_gen;

                                                                                                                                                               {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E1() throws ParseException {
                                           Exp exp0; Exp exp;
    exp0 = E2();
    exp = RE1(exp0);
                                                                                         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE1(Exp exph) throws ParseException {
                                                   Exp exp2; Exp exp;String op;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case And:
    case Or:
      op = OpAI1();
      exp2 = E2();
      exp = RE1(sem.exp(op,exph,exp2));
                                                                                                                                       {if (true) return exp;}
      break;
    default:
      jj_la1[16] = jj_gen;

                                                                                                                                                         {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E2() throws ParseException {
                                           Exp exp; Exp exp0;
    exp0 = E3();
    exp = RE2(exp0);
                                                                                         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE2(Exp exph) throws ParseException {
                                                   String op; Exp exp; Exp exp2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
      op = OpAI2();
      exp2 = E3();
      exp = RE2(sem.exp(op,exph,exp2));
                                                                                                                                          {if (true) return exp;}
      break;
    default:
      jj_la1[17] = jj_gen;

                                                                                                                                                             {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E3() throws ParseException {
                                           Exp exp0; Exp exp;
    exp0 = E4();
    exp = RE3(exp0);
                                                                                         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE3(Exp exph) throws ParseException {
                                                   String op; Exp exp0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
    case 64:
    case 65:
      op = OpNA3();
      exp0 = E4();
                                                                                                {if (true) return sem.exp(op,exph,exp0);}
      break;
    default:
      jj_la1[18] = jj_gen;

                                                                                                                                    {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E4() throws ParseException {
                                           Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 54:
      jj_consume_token(54);
      exp = E5();
                                                                    {if (true) return sem.menos(exp);}
      break;
    case Not:
      jj_consume_token(Not);
      exp = E4();
                                                                                                             {if (true) return sem.not(exp);}
      break;
    case True:
    case False:
    case Null:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
    case 57:
      exp = E5();

      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E5() throws ParseException {
                                           Exp exp; Exp exp0;
    exp0 = E6();
    exp = RE5(exp0);
                                                                                         {if (true) return exp;}
    throw new Error("Missing return statement in function");
  }

  final public Exp RE5(Exp exph) throws ParseException {
                                                   Exp exp0; Token id;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 55:
      jj_consume_token(55);
      id = jj_consume_token(Id);
                                                                                      {if (true) return sem.reg_punto(exph,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case 56:
      jj_consume_token(56);
      id = jj_consume_token(Id);
                                                                                                                               {if (true) return sem.reg_flecha(exph,sem.str(id.image,id.beginLine,id.beginColumn));}
      break;
    case 48:
      jj_consume_token(48);
      exp0 = E0();
      jj_consume_token(49);
                                                                                                                                    {if (true) return sem.indice(exph,exp0);}
      break;
    default:
      jj_la1[20] = jj_gen;

                                                                                                                                                                         {if (true) return exph;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E6() throws ParseException {
                                           Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
      jj_consume_token(57);
      exp = E6();
                                                                    {if (true) return sem.indirecto(exp);}
      break;
    case True:
    case False:
    case Null:
    case Cadena:
    case Id:
    case Entero:
    case Real:
    case 44:
      exp = E7();
                                                                                                           {if (true) return exp;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Exp E7() throws ParseException {
                                           Token t;Exp exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Entero:
      t = jj_consume_token(Entero);
                                                                          {if (true) return sem.entero(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case Real:
      t = jj_consume_token(Real);
                                                                                                          {if (true) return sem.real(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case True:
      jj_consume_token(True);
                                                                                                         {if (true) return sem._true();}
      break;
    case False:
      jj_consume_token(False);
                                                                                                                                        {if (true) return sem._false();}
      break;
    case Cadena:
      t = jj_consume_token(Cadena);
                                                                                                              {if (true) return sem.cadena(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case Id:
      t = jj_consume_token(Id);
                                                                                                          {if (true) return sem.identif(sem.str(t.image,t.beginLine,t.beginColumn));}
      break;
    case Null:
      jj_consume_token(Null);
                                                                                                        {if (true) return sem._null();}
      break;
    case 44:
      jj_consume_token(44);
      exp = E0();
      jj_consume_token(45);
                                                                                                                                                   {if (true) return exp;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpAI1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case And:
      jj_consume_token(And);
                                             {if (true) return "and";}
      break;
    case Or:
      jj_consume_token(Or);
                                                                   {if (true) return "or";}
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpAI2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 58:
      jj_consume_token(58);
                                            {if (true) return "=";}
      break;
    case 59:
      jj_consume_token(59);
                                                               {if (true) return "<";}
      break;
    case 60:
      jj_consume_token(60);
                                                                                   {if (true) return ">";}
      break;
    case 61:
      jj_consume_token(61);
                                                                                                       {if (true) return "<=";}
      break;
    case 62:
      jj_consume_token(62);
                                                                                                                            {if (true) return ">=";}
      break;
    case 63:
      jj_consume_token(63);
                                                                                                                                                 {if (true) return "!=";}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String OpNA3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 57:
      jj_consume_token(57);
                                           {if (true) return "*";}
      break;
    case 64:
      jj_consume_token(64);
                                                              {if (true) return "/";}
      break;
    case 65:
      jj_consume_token(65);
                                                                                 {if (true) return "%";}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public AnalizadorSintacticoTiny1JavaCCTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0xe0000,0x0,0xe0000,0x60000f00,0x0,0x0,0x60000f00,0x0,0x0,0x1231c000,0x1800000,0x11c000,0x0,0x1231c000,0x123fc000,0x0,0x3000,0x0,0x0,0x11c000,0x0,0x118000,0x118000,0x3000,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x800,0x0,0x81,0x4000,0x8080,0x81,0x800,0x800,0x24413fe,0x0,0x24013c0,0x4000,0x24413fe,0x24c13fe,0x600000,0x0,0xfc000000,0x2000000,0x24013c0,0x1810000,0x20013c0,0x13c0,0x0,0xfc000000,0x2000000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3,};
   }

  public AnalizadorSintacticoTiny1JavaCC(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnalizadorSintacticoTiny1JavaCCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public AnalizadorSintacticoTiny1JavaCC(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnalizadorSintacticoTiny1JavaCCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public AnalizadorSintacticoTiny1JavaCC(AnalizadorSintacticoTiny1JavaCCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(AnalizadorSintacticoTiny1JavaCCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[66];
    for (int i = 0; i < 66; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 66; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
